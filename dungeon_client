#!/usr/bin/env python3
# -*- coding: utf-8 -*-
# pylint: disable=W1203

'''
    ICE Gauntlet REMOTE GAME
'''

import sys
import atexit
import argparse
import Ice
import game
import game.common
import game.screens
import game.pyxeltools
import game.orchestration
from game.common import LIFE, LEVEL_COUNT, AVAILABLE_OBJECT_IDS, EMPTY_TILE, NULL_TILE, HEROES,\
    OBJECT_CLASS, OBJECT_TYPE, IDENTIFIER

Ice.loadSlice('icegauntlet.ice')
# pylint: disable=E0401
# pylint: disable=C0413
import IceGauntlet
# pylint: enable=E0401
# pylint: enable=C0413


EXIT_OK = 0
BAD_COMMAND_LINE = 1

DEFAULT_HERO = game.common.HEROES[0]

class RemoteDungeonMap(Ice.Application):
    '''Store a list of rooms'''
    def __init__(self, dungeon_proxy, hero, dungeon_area_sync_proxy):
        self.dungeon_proxy=dungeon_proxy
        self.hero = hero
        self.dungeon_servant = None
        self.dungeon_area_sync_proxy = dungeon_area_sync_proxy

    def run (self, args):
        dungeon_proxy = self.communicator().stringToProxy(self.dungeon_proxy)
        self.dungeon_servant = IceGauntlet.DungeonPrx.checkedCast(dungeon_proxy)
        if not self.dungeon_servant:
            raise RuntimeError('Invalid proxy')

        self.shutdownOnInterrupt()

        game.pyxeltools.initialize()
        gauntlet = game.Game(self.hero, self)
        gauntlet.add_state(game.screens.TileScreen, game.common.INITIAL_SCREEN)
        gauntlet.add_state(game.screens.StatsScreen, game.common.STATUS_SCREEN)
        gauntlet.add_state(game.screens.GameScreen, game.common.GAME_SCREEN)
        gauntlet.add_state(game.screens.GameOverScreen, game.common.GAME_OVER_SCREEN)
        gauntlet.add_state(game.screens.GoodEndScreen, game.common.GOOD_END_SCREEN)

        try:
            gauntlet.start()
        except SystemExit:
            pass

    @property
    def next_area(self):
        '''To obtain a new room'''
        self._current_area_ = RemoteArea(self.dungeon_servant.getEntrance(), self.dungeon_area_sync_proxy)
        _current_area_.main(sys.argv)
        return self._current_area_


    @property
    def finished(self):
        '''To know if the game has finished'''
        return False

    def abandon_area(self):
        self._current_area_.abandon()

class RemoteArea(Ice.Application):
    def __init__(self, level, dungeon_area_sync_proxy):
        self.dungeon_area_sync_proxy = dungeon_area_sync_proxy
        self.event_handler = self.__send_event__
        self.roomName, self.author, roomData = load_json_map(level)
        self.objects = []
        self.roomData = []
        y = 0
        for row in roomData:
            x = 0
            filteredRow = []
            for tile in row:
                if (tile in AVAILABLE_OBJECT_IDS):
                    filteredRow.append(EMPTY_TILE)
                    self.objects.append((str(uuid.uuid4()), tile, (x, y)))
                elif (tile == NULL_TILE):
                    filteredRow.append(EMPTY_TILE)
                else:
                    filteredRow.append(tile)
                x += 1
            y += 1
            self.roomData.append(filteredRow)

    def run (self, args):
        dungeon_area_sync_proxy = self.communicator().stringToProxy(self.dungeon_area_sync_proxy)
        self.dungeon_area_sync_servant = IceGauntlet.DungeonAreaPrx.checkedCast(dungeon_area_sync_proxy)
        if not self.dungeon_area_sync_servant:
            raise RuntimeError('Invalid proxy')

    def getMap(self):
        return self.roomName, self.author, self.roomData

    def getObjects(self):
        return self.objects

    def getActors(self):
        return []
    
    def fire_event(self, event, only_local=False):
        if not only_local:
            self.event_handler(event)

    def abandon(self):
        pass

    def __send_event__(self, event):
        self.dungeon_area_sync_servant.fireEvent(event, ) #TODO get the identifier

@atexit.register
# pylint: disable=W0613
def bye(*args, **kwargs):
    '''Exit callback, use for shoutdown'''
    print('Thanks for playing!')
# pylint: enable=W0613

def parse_commandline():
    '''Parse and check commandline'''
    parser = argparse.ArgumentParser('IceDungeon Local Game')
    parser.add_argument('PROXY', type=str, help = 'proxy of the Map server')
    parser.add_argument('DUNGEON_AREA_SYNC_PROXY', type=str, help = 'proxy of the Game server')
    parser.add_argument(
        '-p', '--player', default=DEFAULT_HERO, choices=game.common.HEROES,
        dest='hero', help='Hero to play with'
    )
    options = parser.parse_args()

    return options


def main():
    '''Start game according to commandline'''
    user_options = parse_commandline()
    if not user_options:
        return BAD_COMMAND_LINE

    dungeon = RemoteDungeonMap(user_options.PROXY, user_options.hero, user_options.DUNGEON_AREA_SYNC_PROXY)
    dungeon.main(sys.argv)

    return EXIT_OK


if __name__ == '__main__':
    sys.exit(main())
