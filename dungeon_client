#!/usr/bin/env python3
# -*- coding: utf-8 -*-
# pylint: disable=W1203

'''
    ICE Gauntlet REMOTE GAME
'''

import sys
import uuid
import atexit
import argparse
import Ice
import IceStorm
import game
import game.common
import game.screens
import game.pyxeltools
import game.orchestration
import icegauntlettool
from game.common import LIFE, LEVEL_COUNT, AVAILABLE_OBJECT_IDS, EMPTY_TILE, NULL_TILE, HEROES,\
    OBJECT_CLASS, OBJECT_TYPE, IDENTIFIER

Ice.loadSlice('icegauntlet.ice')
# pylint: disable=E0401
# pylint: disable=C0413
import IceGauntlet
# pylint: enable=E0401
# pylint: enable=C0413


EXIT_OK = 0
BAD_COMMAND_LINE = 1

DEFAULT_HERO = game.common.HEROES[0]

class RemoteDungeonMap(Ice.Application):
    '''Store a list of rooms'''
    def __init__(self, dungeon_proxy, hero):
        self.dungeon_proxy=dungeon_proxy
        self.hero = hero
        self.dungeon_servant = None
        self.game_id = str(uuid.uuid4())
        self._current_area_=None

    def run (self, args):
        dungeon_proxy = self.communicator().stringToProxy(self.dungeon_proxy)
        self.dungeon_servant = IceGauntlet.DungeonPrx.checkedCast(dungeon_proxy)
        if not self.dungeon_servant:
            raise RuntimeError('Invalid proxy')

        self.shutdownOnInterrupt()

        game.pyxeltools.initialize()
        gauntlet = game.Game(self.hero, self, self.game_id)
        gauntlet.add_state(game.screens.TileScreen, game.common.INITIAL_SCREEN)
        gauntlet.add_state(game.screens.StatsScreen, game.common.STATUS_SCREEN)
        gauntlet.add_state(game.screens.GameScreen, game.common.GAME_SCREEN)
        gauntlet.add_state(game.screens.GameOverScreen, game.common.GAME_OVER_SCREEN)
        gauntlet.add_state(game.screens.GoodEndScreen, game.common.GOOD_END_SCREEN)

        try:
            gauntlet.start()
        except SystemExit:
            pass

    @property
    def next_area(self):
        '''To obtain a new room'''
        if not self._current_area_:
            self._current_area_ = RemoteArea(self.dungeon_servant.getEntrance(), self.game_id)
        else:
            self._current_area_ = self._current_area_.dungeon_area.getNextArea()
        _current_area_.main(sys.argv)
        return self._current_area_


    @property
    def finished(self):
        '''To know if the game has finished'''
        return False

    def abandon_area(self):
        self._current_area_.abandon()

class RemoteArea(Ice.Application):
    def __init__(self, dungeon_area, game_id):
        self.game_id=game_id
        self.dungeon_area = dungeon_area
        self.roomName, self.author, roomData = game.pyxeltools.load_json_map(self.dungeon_area.getMap())
        self.objects = self.dungeon_area.getItems()
        self.roomData = []
        self.actors = self.dungeon_area.getActors()
        y = 0
        for row in roomData:
            x = 0
            filteredRow = []
            for tile in row:
                if (tile in AVAILABLE_OBJECT_IDS):
                    filteredRow.append(EMPTY_TILE)
                    self.objects.append((str(uuid.uuid4()), tile, (x, y)))
                elif (tile == NULL_TILE):
                    filteredRow.append(EMPTY_TILE)
                else:
                    filteredRow.append(tile)
                x += 1
            y += 1
            self.roomData.append(filteredRow)

    def get_topic_manager(self):
        key = 'IceStorm.TopicManager.Proxy'
        proxy = self.communicator().stringToProxy("IceStorm/TopicManager:tcp -p 10000")
        if proxy is None:
            print("property '{}' not set".format(key))
            return None

    def run (self, args):
        topic_mgr = self.get_topic_manager()
        if not topic_mgr:
            print('Invalid proxy')
            return 2
        self.topic_name=self.dungeon_area.getEventChannel()
        try:
            topic = topic_mgr.retrieve(topic_name)
        except IceStorm.NoSuchTopic:
            print("No such topic found, crating")
            topic=topic_mgr.create(topic_name)
        ic = self.communicator()
        servant = DungeonAreaSyncI(self)
        adapter = ic.createObjectAdapter("DungeonAreaAdapter")
        subscriber= adapter.addWithUUID(servant)
        publisher=topic.subscribeAndGetPublisher({},subscriber)
        self.dungeon_area_sync_publisher=IceGauntlet.DungeonAreaSyncPrx.uncheckedCast(publisher)

    def getMap(self):
        return self.roomName, self.author, self.roomData

    def getObjects(self):
        return self.objects

    def getActors(self):
        return self.actors
    
    def fire_event(self, event, only_local=False):
        if not only_local:
            self.event_handler(event, self.game_id)

    def abandon(self):
        pass

    def event_handler(self, event, senderId):
        if self.game_id == senderId:
            self.dungeon_area_sync_publisher.fireEvent(event, self.game_id)
        else:
            if event[0] == "spawn_actor":
                self.actors.append(event[1:])
            elif event[0] == "kill_object":
                self.objects = [obj for obj in self.objects if obj[0] != event[1]]
                self.actors = [act for act in self.actors if act[0] != event[1]]

            elif event[0] == "open_door":
                ##door_touched=
                ##icegauntlettool.search_adjacent_door(door_touched)
                ##self.actors.append(event[1:])
                pass


class DungeonAreaSyncI(IceGauntlet.DungeonAreaSync):
    def __init__(self, dungeon_area):
        self.dungeon_area = dungeon_area

    def fireEvent(self, event, senderId, current=None):
        event = pickle.loads(event)

        self.dungeon_area.event_handler(event, senderId)

@atexit.register
# pylint: disable=W0613
def bye(*args, **kwargs):
    '''Exit callback, use for shoutdown'''
    print('Thanks for playing!')
# pylint: enable=W0613

def parse_commandline():
    '''Parse and check commandline'''
    parser = argparse.ArgumentParser('IceDungeon Local Game')
    parser.add_argument('PROXY', type=str, help = 'proxy of the Map server')
    parser.add_argument(
        '-p', '--player', default=DEFAULT_HERO, choices=game.common.HEROES,
        dest='hero', help='Hero to play with'
    )
    options = parser.parse_args()

    return options


def main():
    '''Start game according to commandline'''
    user_options = parse_commandline()
    if not user_options:
        return BAD_COMMAND_LINE

    dungeon = RemoteDungeonMap(user_options.PROXY, user_options.hero)
    dungeon.main(sys.argv)

    return EXIT_OK


if __name__ == '__main__':
    sys.exit(main())
